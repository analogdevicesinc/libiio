<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libiio: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libiio
   &#160;<span id="projectnumber">0.26</span>
   </div>
   <div id="projectbrief">Library for interfacing with IIO devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libiio Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#license">License</a></li>
<li class="level1"><a href="#code_model">Code Model</a></li>
<li class="level1"><a href="#scan_contexts">Scanning for IIO contexts</a></li>
<li class="level1"><a href="#creating_context">Creating a context</a><ul><li class="level2"><a href="#navigation">Navigation</a><ul><li class="level3"><a href="#device_obj">Device objects</a></li>
<li class="level3"><a href="#channel_obj">Channel objects</a></li>
</ul>
</li>
<li class="level2"><a href="#list_params">Parameters</a></li>
</ul>
</li>
<li class="level1"><a href="#reading_modify_params">Reading and modifying parameters</a><ul><li class="level2"><a href="#read_param">Reading a parameter</a></li>
<li class="level2"><a href="#write_param">Modifying a parameter</a></li>
</ul>
</li>
<li class="level1"><a href="#trigger">Triggers</a></li>
<li class="level1"><a href="#capture_upload">Capturing or uploading samples</a><ul><li class="level2"><a href="#create_buffer">Enabling channels and creating the Buffer object</a></li>
<li class="level2"><a href="#refill">Refilling the Buffer (input devices only)</a></li>
<li class="level2"><a href="#read_write">Reading or writing samples to the Buffer</a><ul><li class="level3"><a href="#memcpy">Direct copy</a></li>
<li class="level3"><a href="#iterating_cb">Iterating over the buffer with a callback</a></li>
<li class="level3"><a href="#iterating_for">Iterating on the samples with a for loop</a></li>
<li class="level3"><a href="#deinterleave">Extracting from/to a second buffer</a></li>
</ul>
</li>
<li class="level2"><a href="#convert">Convert the samples from/to hardware format</a></li>
<li class="level2"><a href="#push">Submitting the Buffer (output devices only)</a></li>
</ul>
</li>
<li class="level1"><a href="#advanced">Advanced options</a><ul><li class="level2"><a href="#userdata">Register and retrieve a pointer</a></li>
<li class="level2"><a href="#debug_attr">Debug attributes</a></li>
<li class="level2"><a href="#registers">Reading and writing registers</a></li>
</ul>
</li>
<li class="level1"><a href="#abi">Application Binary Interface</a></li>
</ul>
</div>
<div class="textblock"><p><a href="../index.html">Back to libIIO</a></p>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>Libiio has been developed and is released under the terms of the GNU Lesser General Public License, version 2 or (at your option) any later version. This open-source license allows anyone to use the library for proprietary or open-source, commercial or non-commercial applications.</p>
<p>Separately, the IIO Library also includes a set of test examples and utilities, (collectively known as iio-utils) which are developed and released under the terms of the GNU General Public License, version 2 or (at your option) any later version.</p>
<p>The full terms of the library license can be found at: <a href="http://opensource.org/licenses/LGPL-2.1">http://opensource.org/licenses/LGPL-2.1</a> and the iio-utils license can be found at: <a href="https://opensource.org/licenses/GPL-2.0">https://opensource.org/licenses/GPL-2.0</a></p>
<h1><a class="anchor" id="code_model"></a>
Code Model</h1>
<p>The basic bricks of the libiio API are the <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a>, <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a>, <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> and <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> classes.</p>
<p><img src="codemodel.svg" alt="" style="pointer-events: none;" class="inline" title="Caption text"/></p>
<ul>
<li>A <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a> object may contain zero or more <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> objects. A <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object is associated with only one <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a>. This object represents an instance of the library.</li>
<li>A <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object may contain zero or more <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> objects. A <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> object is associated with only one <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a>.</li>
<li>A <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object may be associated with one <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object, and a <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object is associated with only one <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a>.</li>
</ul>
<h1><a class="anchor" id="scan_contexts"></a>
Scanning for IIO contexts</h1>
<p>The first step when dealing with a collection of IIO devices (known as a context) is to find the context. This can be connected via usb, network, serial or local. Having these different connectivity options could prove to be problematic, but libiio abstracts the low level communications away, and allows you just to find contexts, and talk to devices without being interested in the low level aspects. Many find this convenient to develop applications and algorithms on a host, and quickly move to an embedded Linux system without having to change any code.</p>
<p>To find what IIO contexts are available, use the following:</p><ul>
<li><a class="el" href="group__Scan.html#gaa333dd2e410a2769cf5685019185d99c" title="Create a scan context.">iio_create_scan_context()</a>: Create a iio_scan_context object. Depending on what backends were enabled with compiling the library, some of them may not be available. The first argument to this function is a string which is used as a filter ("usb:", "ip:", "local:", "usb:ip", where the default (NULL) means any backend that is compiled in).</li>
<li><a class="el" href="group__Scan.html#ga5d364d8d008bdbfe5486e6329d06257f" title="Enumerate available contexts.">iio_scan_context_get_info_list()</a>: get the <a class="el" href="structiio__context__info.html" title="The information related to a discovered context.">iio_context_info</a> object from the iio_scan_context object. The <a class="el" href="structiio__context__info.html" title="The information related to a discovered context.">iio_context_info</a> object can be examined with the <a class="el" href="group__Scan.html#ga885558697d0e4dad11a4a5b6f5fbc4d6" title="Get a description of a discovered context.">iio_context_info_get_description()</a> and <a class="el" href="group__Scan.html#ga6a142a62112a0f84370d22facb2f2a37" title="Get the URI of a discovered context.">iio_context_info_get_uri()</a> to determine which uri you want to attach to.</li>
</ul>
<h1><a class="anchor" id="creating_context"></a>
Creating a context</h1>
<p>Different functions are available to create the <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a> object. Depending on what backends were enabled when compiling the library, some of them may not be available. Each function will result in a different backend being used.</p>
<p>Those functions are:</p><ul>
<li><a class="el" href="group__Context.html#gafdcee40508700fa395370b6c636e16fe" title="Create a context from a URI description.">iio_create_context_from_uri()</a>: This should be the main function to create contexts, which takes a Uniform Resource Identifier (uri), and returns a <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a>.</li>
<li><a class="el" href="group__Context.html#ga21076125f817a680e0c01d4a490f0416" title="Create a context from local or remote IIO devices.">iio_create_default_context()</a>: Create a "local" context if we can, otherwise use the ENV_VAR IIOD_REMOTE.</li>
<li><a class="el" href="group__Context.html#gaf31acec2d0f9f498870cc52a1d49783e" title="Create a context from local IIO devices (Linux only)">iio_create_local_context()</a>: Create a "local" context, to use the IIO devices connected to the system (typically for cross-compiled applications).</li>
<li><a class="el" href="group__Context.html#ga8adf2ef4d2b62aa34201469cd7049617" title="Create a context from the network.">iio_create_network_context()</a>: Create a "network" context that will work with a remotely connected target.</li>
</ul>
<p>Note that every function that compose the API of libiio will work independently of the function that was used to create the <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a> object.</p>
<p>The <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a> object can later be destroyed with <a class="el" href="group__Context.html#ga75de8dae515c539818e52b408830d3ba" title="Destroy the given context.">iio_context_destroy()</a>.</p>
<h2><a class="anchor" id="navigation"></a>
Navigation</h2>
<h3><a class="anchor" id="device_obj"></a>
Device objects</h3>
<ul>
<li>From the <a class="el" href="structiio__context.html" title="Contains the representation of an IIO context.">iio_context</a> object, you can obtain the number of available devices with <a class="el" href="group__Context.html#gab4fc2a93fd5824f3c9e06aa81e8097d1" title="Enumerate the devices found in the given context.">iio_context_get_devices_count()</a>.</li>
<li>Then, each <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object can be accessed with <a class="el" href="group__Context.html#ga3f2813ff34bf96c7c85dd05909f1c709" title="Get the device present at the given index.">iio_context_get_device()</a>.</li>
<li>Alternatively, it is possible to lookup for a device name or ID with <a class="el" href="group__Context.html#gade1dadfb5bc3c3b236add67f803c50c3" title="Try to find a device structure by its ID, label or name.">iio_context_find_device()</a>.</li>
</ul>
<p>Each <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object has an ID that can be used as identifier. This ID can be retrieved with <a class="el" href="group__Device.html#ga9e6610c3dd7cc45bebcc7ed7a1b064c6" title="Retrieve the device ID (e.g. iio:device0)">iio_device_get_id()</a>. It optionally also has a name, that can be retrieved with <a class="el" href="group__Device.html#ga711666b3b3b6314fbe7e592b4632ab85" title="Retrieve the device name (e.g. xadc)">iio_device_get_name()</a>.</p>
<h3><a class="anchor" id="channel_obj"></a>
Channel objects</h3>
<ul>
<li>From the <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object, you can obtain the number of available channels with <a class="el" href="group__Device.html#gae10ff440f64dac52b4229eb3f2ebea76" title="Enumerate the channels of the given device.">iio_device_get_channels_count()</a>.</li>
<li>Then, each <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> object can be accessed with <a class="el" href="group__Device.html#ga67289d735b7d8e1ed12ae0ea642bd1ac" title="Get the channel present at the given index.">iio_device_get_channel()</a>.</li>
<li>Alternatively, it is possible to lookup for a channel name or ID with <a class="el" href="group__Device.html#gaffc6086189ba801ab5e95341d68f882b" title="Try to find a channel structure by its name of ID.">iio_device_find_channel()</a>.</li>
</ul>
<p>Each <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> can be either input, or output. This information can be retrieved with <a class="el" href="group__Channel.html#ga3c24e9c93e2217c9506073d04b878461" title="Return True if the given channel is an output channel.">iio_channel_is_output()</a>. As for the Device objects, the <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> object features an ID and optionally a name. The ID can be obtained with <a class="el" href="group__Channel.html#gafda1782de4655905ad08a40492f3dc64" title="Retrieve the channel ID (e.g. voltage0)">iio_channel_get_id()</a>, and the name can be obtained with <a class="el" href="group__Channel.html#ga37346a6f3fcfb1eb40572aec6c3b39ac" title="Retrieve the channel name (e.g. vccint)">iio_channel_get_name()</a>. Important note: two <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> can have the same ID, as long as one is input and the other is output.</p>
<h2><a class="anchor" id="list_params"></a>
Parameters</h2>
<p>Different kinds of parameters are available: parameters that apply to a <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a>, and parameters that apply to one or more <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a>.</p><ul>
<li>The number of device-specific parameters can be obtained with <a class="el" href="group__Device.html#ga36c2d0f703a803f44a578bc83fdab6a0" title="Enumerate the device-specific attributes of the given device.">iio_device_get_attrs_count()</a>. Each attribute name can be obtained with <a class="el" href="group__Device.html#ga70b03d4cb3cc3c4fb1b6451764c8ccec" title="Get the device-specific attribute present at the given index.">iio_device_get_attr()</a>.</li>
<li>The number of channel-specific attributes can be obtained with <a class="el" href="group__Channel.html#ga14869c3fda8b04f413a02f15dfa6ef7c" title="Enumerate the channel-specific attributes of the given channel.">iio_channel_get_attrs_count()</a>. Each attribute name can be obtained with <a class="el" href="group__Channel.html#gafc3c52f360424c097a24d1925923d772" title="Get the channel-specific attribute present at the given index.">iio_channel_get_attr()</a>.</li>
</ul>
<p>Alternatively, it is possible to lookup for the name of an attribute with <a class="el" href="group__Device.html#gafcbece1ac6260b06bcdf02d9eb55e5fd" title="Try to find a device-specific attribute by its name.">iio_device_find_attr()</a> and <a class="el" href="group__Channel.html#ga13b2db3252a2380a2b0b1bb15b8034a4" title="Try to find a channel-specific attribute by its name.">iio_channel_find_attr()</a>.</p>
<h1><a class="anchor" id="reading_modify_params"></a>
Reading and modifying parameters</h1>
<h2><a class="anchor" id="read_param"></a>
Reading a parameter</h2>
<p>Read device-specific attributes with those functions:</p><ul>
<li><a class="el" href="group__Device.html#gaf0233eb0ef4a64ad70ebaef6328b0494" title="Read the content of the given device-specific attribute.">iio_device_attr_read()</a></li>
<li><a class="el" href="group__Device.html#ga5b1fef1333c4835942384b661f148b36" title="Read the content of all device-specific attributes.">iio_device_attr_read_all()</a></li>
<li><a class="el" href="group__Device.html#ga96364b7c7097bb8e4656924ea896a502" title="Read the content of the given device-specific attribute.">iio_device_attr_read_bool()</a></li>
<li><a class="el" href="group__Device.html#ga0f7b5d21a4e40efac68e1ece44d7ba74" title="Read the content of the given device-specific attribute.">iio_device_attr_read_longlong()</a></li>
<li><a class="el" href="group__Device.html#gab1b150a5bfa7b1ab7fd76c538e15e4da" title="Read the content of the given device-specific attribute.">iio_device_attr_read_double()</a></li>
</ul>
<p>Read channel-specific attributes with those functions:</p><ul>
<li><a class="el" href="group__Channel.html#ga2c2ca5696d1341067051eb390d5014ae" title="Read the content of the given channel-specific attribute.">iio_channel_attr_read()</a></li>
<li><a class="el" href="group__Channel.html#gab9c28b0cd94c0607bcc7cac16219eb48" title="Read the content of all channel-specific attributes.">iio_channel_attr_read_all()</a></li>
<li><a class="el" href="group__Channel.html#ga319f39c313bbd4d331e23df51e4d3ce6" title="Read the content of the given channel-specific attribute.">iio_channel_attr_read_bool()</a></li>
<li><a class="el" href="group__Channel.html#ga116c61892bf3d20ff07efd642c5dfbe1" title="Read the content of the given channel-specific attribute.">iio_channel_attr_read_longlong()</a></li>
<li><a class="el" href="group__Channel.html#ga75ac9b81eb7e7e8a961afb67748e4102" title="Read the content of the given channel-specific attribute.">iio_channel_attr_read_double()</a></li>
</ul>
<p>Read debug attributes with those functions:</p><ul>
<li><a class="el" href="group__Debug.html#ga8d786ee19093f86da4feb92fb91dd5d7" title="Read the content of the given debug attribute.">iio_device_debug_attr_read()</a></li>
<li><a class="el" href="group__Debug.html#ga1fb487123cf36ea55b650165d49a91ff" title="Read the content of all debug attributes.">iio_device_debug_attr_read_all()</a></li>
<li><a class="el" href="group__Debug.html#gadffd69effb8ff8ddb504ea9492a29529" title="Read the content of the given debug attribute.">iio_device_debug_attr_read_bool()</a></li>
<li><a class="el" href="group__Debug.html#gaff27d1a48f8469531c25471918d0b6de" title="Read the content of the given debug attribute.">iio_device_debug_attr_read_longlong()</a></li>
<li><a class="el" href="group__Debug.html#ga1356356c2eebcb56df2d72e93042d896" title="Read the content of the given debug attribute.">iio_device_debug_attr_read_double()</a></li>
</ul>
<h2><a class="anchor" id="write_param"></a>
Modifying a parameter</h2>
<p>Write device-specific attributes with those functions:</p><ul>
<li><a class="el" href="group__Device.html#gaaa2d1867c15ef8f8424164d0ccea4dd8" title="Set the value of the given device-specific attribute.">iio_device_attr_write()</a></li>
<li><a class="el" href="group__Device.html#gadfbbfafabc32d6954d3f3dfcda957735" title="Set the values of all device-specific attributes.">iio_device_attr_write_all()</a></li>
<li><a class="el" href="group__Device.html#ga9f53f9d1c3dc9f87191943fcbd1a7324" title="Set the value of the given device-specific attribute.">iio_device_attr_write_bool()</a></li>
<li><a class="el" href="group__Device.html#ga3fcba684f6b07d3f6295759bb788c4d2" title="Set the value of the given device-specific attribute.">iio_device_attr_write_longlong()</a></li>
<li><a class="el" href="group__Device.html#gacdaf529f12b46ba2a5290bbc590c8b9e" title="Set the value of the given device-specific attribute.">iio_device_attr_write_double()</a></li>
</ul>
<p>Write channel-specific attributes with those functions:</p><ul>
<li><a class="el" href="group__Channel.html#ga35c76ce5fcae4c551b7c78d648665a41" title="Set the value of the given channel-specific attribute.">iio_channel_attr_write()</a></li>
<li><a class="el" href="group__Channel.html#ga6df693ee4f0c329d957f7c7ca3588f3f" title="Set the values of all channel-specific attributes.">iio_channel_attr_write_all()</a></li>
<li><a class="el" href="group__Channel.html#ga9a385b9b05d20f33f8e587feb2ebe81a" title="Set the value of the given channel-specific attribute.">iio_channel_attr_write_bool()</a></li>
<li><a class="el" href="group__Channel.html#gac55cb77a1baf797e54a8a4e31b2f4680" title="Set the value of the given channel-specific attribute.">iio_channel_attr_write_longlong()</a></li>
<li><a class="el" href="group__Channel.html#gad9d6ec4a02948c6416cc99254bdbfa50" title="Set the value of the given channel-specific attribute.">iio_channel_attr_write_double()</a></li>
</ul>
<p>Write debug attributes with those functions:</p><ul>
<li><a class="el" href="group__Debug.html#gaea7f639edb7efd15b718be4c7faaeae5" title="Set the value of the given debug attribute.">iio_device_debug_attr_write()</a></li>
<li><a class="el" href="group__Debug.html#ga57e3af5219859303c2a8629e9b80f9ca" title="Set the values of all debug attributes.">iio_device_debug_attr_write_all()</a></li>
<li><a class="el" href="group__Debug.html#ga40579d97ca0b68f2244bed67ece80ce6" title="Set the value of the given debug attribute.">iio_device_debug_attr_write_bool()</a></li>
<li><a class="el" href="group__Debug.html#ga22df5b7b0606a9e453fac421d15e6fb2" title="Set the value of the given debug attribute.">iio_device_debug_attr_write_longlong()</a></li>
<li><a class="el" href="group__Debug.html#ga2a4e26d2d33db7fe9fc76d3034cb264f" title="Set the value of the given debug attribute.">iio_device_debug_attr_write_double()</a></li>
</ul>
<h1><a class="anchor" id="trigger"></a>
Triggers</h1>
<p>Some devices, mostly low-speed ADCs and DACs, require a trigger to be set for the capture or upload process to work.</p>
<p>In libiio, triggers are just regular <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> objects. To check if an <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> can be used as a trigger, you can use <a class="el" href="group__Device.html#ga7e3e5dee1ac8c082de038829c88edda8" title="Return True if the given device is a trigger.">iio_device_is_trigger()</a>.</p>
<p>To see if one device is associated with a trigger, use <a class="el" href="group__Device.html#gae3ce1d7385ca02a9f6c36768fa41c610" title="Retrieve the trigger of a given device.">iio_device_get_trigger()</a>.</p>
<p>To assign one trigger to a <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a>, you can use <a class="el" href="group__Device.html#ga3b8d1e621357f0755925d98555f53d9a" title="Associate a trigger to a given device.">iio_device_set_trigger()</a>. If you want to disassociate a <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> from its trigger, pass NULL to the "trigger" parameter of this function.</p>
<h1><a class="anchor" id="capture_upload"></a>
Capturing or uploading samples</h1>
<p>The process of capturing samples from the hardware and uploading samples to the hardware is done using the functions that apply to the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object.</p>
<h2><a class="anchor" id="create_buffer"></a>
Enabling channels and creating the Buffer object</h2>
<p>The very first step is to enable the capture channels that we want to use, and disable those that we don't need. This is done with the functions <a class="el" href="group__Channel.html#ga2b787983683d37966b5e1e5c6c121d6a" title="Enable the given channel.">iio_channel_enable()</a> and <a class="el" href="group__Channel.html#gad7c7c91c61b8a97187dc73cbcdb60c06" title="Disable the given channel.">iio_channel_disable()</a>. Note that the channels will really be enabled or disabled when the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object is created.</p>
<p>Also, not all channels can be enabled. To know whether or not one channel can be enabled, use <a class="el" href="group__Channel.html#ga07892a3c0c31e7a3eecf76ec72a8669d" title="Return True if the given channel is a scan element.">iio_channel_is_scan_element()</a>.</p>
<p>Once the channels have been enabled, and triggers assigned (for triggered buffers) the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object can be created from the <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object that will be used, with the function <a class="el" href="group__Buffer.html#gaea8067aca27b93a1260a0c563607a501" title="Create an input or output buffer associated to the given device.">iio_device_create_buffer()</a>. This call will fail if no channels have been enabled, or for triggered buffers, if the trigger has not been assigned.</p>
<p>When the object is no more needed, it can be destroyed with <a class="el" href="group__Buffer.html#gaba58dc2780be63fead6f09397ce90d10" title="Destroy the given buffer.">iio_buffer_destroy()</a>.</p>
<h2><a class="anchor" id="refill"></a>
Refilling the Buffer (input devices only)</h2>
<p>If the Buffer object has been created from a device with input channels, then it must be updated first. This is done with the <a class="el" href="group__Buffer.html#gac999e5244b5a2cbbca5ecaef8303a4ff" title="Fetch more samples from the hardware.">iio_buffer_refill()</a> function.</p>
<h2><a class="anchor" id="read_write"></a>
Reading or writing samples to the Buffer</h2>
<p>Libiio offers various ways to interact with the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object.</p>
<h3><a class="anchor" id="memcpy"></a>
Direct copy</h3>
<p>If you already have a buffer of samples, correctly interleaved and in the format that the hardware expects, it is possible to copy the samples directly into the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object using <code>memcpy</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> iio_buf_size = <a class="code" href="group__Buffer.html#gab5300f917bbdfc5dafc093a60138f131">iio_buffer_end</a>(buffer) - <a class="code" href="group__Buffer.html#ga7fdacbfda79aa5120f34ea73ae2ea5ab">iio_buffer_start</a>(buffer);</div>
<div class="line"><span class="keywordtype">size_t</span> count = MAX(<span class="keyword">sizeof</span>(samples_buffer), iio_buf_size);</div>
<div class="line">memcpy(<a class="code" href="group__Buffer.html#ga7fdacbfda79aa5120f34ea73ae2ea5ab">iio_buffer_start</a>(buffer), samples_buffer, count);</div>
<div class="ttc" id="agroup__Buffer_html_ga7fdacbfda79aa5120f34ea73ae2ea5ab"><div class="ttname"><a href="group__Buffer.html#ga7fdacbfda79aa5120f34ea73ae2ea5ab">iio_buffer_start</a></div><div class="ttdeci">void * iio_buffer_start(const struct iio_buffer *buffer)</div><div class="ttdoc">Get the start address of the buffer.</div><div class="ttdef"><b>Definition:</b> buffer.c:245</div></div>
<div class="ttc" id="agroup__Buffer_html_gab5300f917bbdfc5dafc093a60138f131"><div class="ttname"><a href="group__Buffer.html#gab5300f917bbdfc5dafc093a60138f131">iio_buffer_end</a></div><div class="ttdeci">void * iio_buffer_end(const struct iio_buffer *buffer)</div><div class="ttdoc">Get the address that follows the last sample in a buffer.</div><div class="ttdef"><b>Definition:</b> buffer.c:293</div></div>
</div><!-- fragment --><p>Using <code>memcpy</code> to copy samples from the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> is <b>not recommended</b>. When capturing samples from an input device, you cannot assume that the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object contains only the samples you're interested in.</p>
<h3><a class="anchor" id="iterating_cb"></a>
Iterating over the buffer with a callback</h3>
<p>Libiio provides a way to iterate over the buffer by registering a callback function, with the <a class="el" href="group__Buffer.html#ga810ec50155e82331b18ec71d3c507104" title="Call the supplied callback for each sample found in a buffer.">iio_buffer_foreach_sample()</a> function.</p>
<p>The callback function will be called for each "sample slot" of the buffer, which will contain a valid sample if the buffer has been refilled, or correspond to an area where a sample should be stored if using an output device.</p>
<div class="fragment"><div class="line">ssize_t sample_cb(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structiio__channel.html">iio_channel</a> *chn, <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> bytes, <span class="keywordtype">void</span> *d)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Use &quot;src&quot; to read or write a sample for this channel */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="group__Buffer.html#ga810ec50155e82331b18ec71d3c507104">iio_buffer_foreach_sample</a>(buffer, sample_cb, NULL);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Buffer_html_ga810ec50155e82331b18ec71d3c507104"><div class="ttname"><a href="group__Buffer.html#ga810ec50155e82331b18ec71d3c507104">iio_buffer_foreach_sample</a></div><div class="ttdeci">__api __check_ret ssize_t iio_buffer_foreach_sample(struct iio_buffer *buf, ssize_t(*callback)(const struct iio_channel *chn, void *src, size_t bytes, void *d), void *data)</div><div class="ttdoc">Call the supplied callback for each sample found in a buffer.</div></div>
<div class="ttc" id="astructiio__channel_html"><div class="ttname"><a href="structiio__channel.html">iio_channel</a></div><div class="ttdoc">Represents an input or output channel of a device.</div></div>
</div><!-- fragment --><p>Note that the callback will be called in the order that the samples appear in the buffer, and only for samples that correspond to channels that were enabled.</p>
<h3><a class="anchor" id="iterating_for"></a>
Iterating on the samples with a for loop</h3>
<p>This method allows you to iterate over the samples slots that correspond to one channel. As such, it is interesting if you want to process the data channel by channel.</p>
<p>It basically consists in a for loop that uses the functions <a class="el" href="group__Buffer.html#ga000d2f4c8b72060db1c38ec905bf4156" title="Find the first sample of a channel in a buffer.">iio_buffer_first()</a>, <a class="el" href="group__Buffer.html#ga5532665a8776cec1c209d6cf8d0bb409" title="Get the step size between two samples of one channel.">iio_buffer_step()</a> and <a class="el" href="group__Buffer.html#gab5300f917bbdfc5dafc093a60138f131" title="Get the address that follows the last sample in a buffer.">iio_buffer_end()</a>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">void</span> *ptr = <a class="code" href="group__Buffer.html#ga000d2f4c8b72060db1c38ec905bf4156">iio_buffer_first</a>(buffer, channel);</div>
<div class="line">           ptr &lt; <a class="code" href="group__Buffer.html#gab5300f917bbdfc5dafc093a60138f131">iio_buffer_end</a>(buffer);</div>
<div class="line">           ptr += <a class="code" href="group__Buffer.html#ga5532665a8776cec1c209d6cf8d0bb409">iio_buffer_step</a>(buffer)) {</div>
<div class="line">    <span class="comment">/* Use &quot;ptr&quot; to read or write a sample for this channel */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__Buffer_html_ga000d2f4c8b72060db1c38ec905bf4156"><div class="ttname"><a href="group__Buffer.html#ga000d2f4c8b72060db1c38ec905bf4156">iio_buffer_first</a></div><div class="ttdeci">void * iio_buffer_first(const struct iio_buffer *buffer, const struct iio_channel *chn)</div><div class="ttdoc">Find the first sample of a channel in a buffer.</div><div class="ttdef"><b>Definition:</b> buffer.c:250</div></div>
<div class="ttc" id="agroup__Buffer_html_ga5532665a8776cec1c209d6cf8d0bb409"><div class="ttname"><a href="group__Buffer.html#ga5532665a8776cec1c209d6cf8d0bb409">iio_buffer_step</a></div><div class="ttdeci">ptrdiff_t iio_buffer_step(const struct iio_buffer *buffer)</div><div class="ttdoc">Get the step size between two samples of one channel.</div><div class="ttdef"><b>Definition:</b> buffer.c:288</div></div>
</div><!-- fragment --><h3><a class="anchor" id="deinterleave"></a>
Extracting from/to a second buffer</h3>
<p>Finally, it is possible to use the <a class="el" href="group__Channel.html#ga5c01edc37b0b57aef503abd5989a6a30" title="Demultiplex and convert the samples of a given channel.">iio_channel_read()</a> and <a class="el" href="group__Channel.html#gacd227a6861960ea2fb49d957f62887dd" title="Demultiplex the samples of a given channel.">iio_channel_read_raw()</a> functions to read samples from the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> to a second byte array. The samples will be deinterleaved if needed. The "raw" variant will only deinterleave the samples, while the other variant will deinterleave and convert the samples.</p>
<p>For output devices, the <a class="el" href="group__Channel.html#ga52c5a5cc138969b32f78db9669a4ffd2" title="Convert and multiplex the samples of a given channel.">iio_channel_write()</a> and <a class="el" href="group__Channel.html#ga350e81855764c159c6aefa12fb78e1c2" title="Multiplex the samples of a given channel.">iio_channel_write_raw()</a> functions are also available. The "raw" variant will only interleave the samples (if needed), while the other variant will interleave and convert the samples back to their hardware format.</p>
<h2><a class="anchor" id="convert"></a>
Convert the samples from/to hardware format</h2>
<p>The raw stream of samples generally isn't in a format that can be directly used in algorithms. Some operations, like endianness conversion and bit-shifting of the samples, have to be performed first.</p>
<p>Libiio offers two functions that can be used to convert samples:</p><ul>
<li><a class="el" href="group__Debug.html#gaf910dce06335badc1ba307526c4112a6" title="Convert the sample from hardware format to host format.">iio_channel_convert()</a>, to convert from the hardware format</li>
<li><a class="el" href="group__Debug.html#gaf0a9a659af18b62ffa0520301402eabb" title="Convert the sample from host format to hardware format.">iio_channel_convert_inverse()</a>, to convert to the hardware format.</li>
</ul>
<p>Those two functions should always be used when manipulating the samples of the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a>. The exception is when <a class="el" href="group__Channel.html#ga5c01edc37b0b57aef503abd5989a6a30" title="Demultiplex and convert the samples of a given channel.">iio_channel_read()</a> or <a class="el" href="group__Channel.html#ga52c5a5cc138969b32f78db9669a4ffd2" title="Convert and multiplex the samples of a given channel.">iio_channel_write()</a> are used, as the conversion is then done internally.</p>
<h2><a class="anchor" id="push"></a>
Submitting the Buffer (output devices only)</h2>
<p>When all the samples have been written to the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object, you can submit the buffer to the hardware with a call to <a class="el" href="group__Buffer.html#gae7033c625d128667a56cf482aa3149bd" title="Send the samples to the hardware.">iio_buffer_push()</a>. As soon as the buffer has been submitted, it can be re-used to store new samples.</p>
<p>If the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> object has been created with the "cyclic" parameter set, and the kernel driver supports cyclic buffers, the submitted buffer will be repeated until the <a class="el" href="structiio__buffer.html" title="An input or output buffer, used to read or write samples.">iio_buffer</a> is destroyed, and no subsequent call to <a class="el" href="group__Buffer.html#gae7033c625d128667a56cf482aa3149bd" title="Send the samples to the hardware.">iio_buffer_push()</a> will be allowed.</p>
<h1><a class="anchor" id="advanced"></a>
Advanced options</h1>
<h2><a class="anchor" id="userdata"></a>
Register and retrieve a pointer</h2>
<p>The <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> and <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> allow you to register a pointer, that can then be retrieved at a later moment.</p><ul>
<li>A pointer can be registered with a <a class="el" href="structiio__device.html" title="Represents a device in the IIO context.">iio_device</a> object using <a class="el" href="group__Device.html#gab566248f50503d8975cf258a1f218275" title="Associate a pointer to an iio_device structure.">iio_device_set_data()</a>, and can be retrieved with <a class="el" href="group__Device.html#ga87cff8d90e1a68e73410e4a527cc5334" title="Retrieve a previously associated pointer of an iio_device structure.">iio_device_get_data()</a>.</li>
<li>A pointer can be registered with a <a class="el" href="structiio__channel.html" title="Represents an input or output channel of a device.">iio_channel</a> object using <a class="el" href="group__Channel.html#ga5150c9b73386d899460ebafbe614f338" title="Associate a pointer to an iio_channel structure.">iio_channel_set_data()</a>, and can be retrieved with <a class="el" href="group__Channel.html#gacbce92eaefb8d61c1e4f0dc042b211e6" title="Retrieve a previously associated pointer of an iio_channel structure.">iio_channel_get_data()</a>.</li>
</ul>
<h2><a class="anchor" id="debug_attr"></a>
Debug attributes</h2>
<p>Some IIO devices provide debug parameters, but their presence is optional. In a similar way than with regular device parameters, the number of debug parameters can be obtained with <a class="el" href="group__Debug.html#gabacd0e63720d19e7335088c2fd19bbdc" title="Enumerate the debug attributes of the given device.">iio_device_get_debug_attrs_count()</a>. Each individual parameter can be retrieved with <a class="el" href="group__Debug.html#gafe451e9a078ed5588b43a4a34cf3b2bc" title="Get the debug attribute present at the given index.">iio_device_get_debug_attr()</a>. Alternatively, it is possible to lookup for the name of a debug attribute with <a class="el" href="group__Debug.html#ga2923f184fc57071db9fda14e16c40a9c" title="Try to find a debug attribute by its name.">iio_device_find_debug_attr()</a>.</p>
<p>Those debug parameters can be read using the following functions:</p><ul>
<li><a class="el" href="group__Debug.html#ga8d786ee19093f86da4feb92fb91dd5d7" title="Read the content of the given debug attribute.">iio_device_debug_attr_read()</a>,</li>
<li><a class="el" href="group__Debug.html#ga1fb487123cf36ea55b650165d49a91ff" title="Read the content of all debug attributes.">iio_device_debug_attr_read_all()</a>,</li>
<li><a class="el" href="group__Debug.html#gadffd69effb8ff8ddb504ea9492a29529" title="Read the content of the given debug attribute.">iio_device_debug_attr_read_bool()</a>,</li>
<li><a class="el" href="group__Debug.html#gaff27d1a48f8469531c25471918d0b6de" title="Read the content of the given debug attribute.">iio_device_debug_attr_read_longlong()</a>,</li>
<li><a class="el" href="group__Debug.html#ga1356356c2eebcb56df2d72e93042d896" title="Read the content of the given debug attribute.">iio_device_debug_attr_read_double()</a>.</li>
</ul>
<p>Those debug parameters can be written using the following functions:</p><ul>
<li><a class="el" href="group__Debug.html#gaea7f639edb7efd15b718be4c7faaeae5" title="Set the value of the given debug attribute.">iio_device_debug_attr_write()</a>,</li>
<li><a class="el" href="group__Debug.html#ga57e3af5219859303c2a8629e9b80f9ca" title="Set the values of all debug attributes.">iio_device_debug_attr_write_all()</a>,</li>
<li><a class="el" href="group__Debug.html#ga40579d97ca0b68f2244bed67ece80ce6" title="Set the value of the given debug attribute.">iio_device_debug_attr_write_bool()</a>,</li>
<li><a class="el" href="group__Debug.html#ga22df5b7b0606a9e453fac421d15e6fb2" title="Set the value of the given debug attribute.">iio_device_debug_attr_write_longlong()</a>,</li>
<li><a class="el" href="group__Debug.html#ga2a4e26d2d33db7fe9fc76d3034cb264f" title="Set the value of the given debug attribute.">iio_device_debug_attr_write_double()</a>.</li>
</ul>
<h2><a class="anchor" id="registers"></a>
Reading and writing registers</h2>
<p>As for debug attributes, some IIO devices also offer the possibility to read and write hardware registers directly. In libiio, this can be done with two functions, <a class="el" href="group__Debug.html#ga70829552f676ef9fc74e755933da05d8" title="Get the value of a hardware register.">iio_device_reg_read()</a> and <a class="el" href="group__Debug.html#ga170d5a84de1d5fdb987113aa90e2a19b" title="Set the value of a hardware register.">iio_device_reg_write()</a>.</p>
<h1><a class="anchor" id="abi"></a>
Application Binary Interface</h1>
<p>The libiio ABI tries to be both backwards and forwards compatible. This means applications compiled against an older version will work fine with a newer dynamically linked library. Applications compiled against a newer version will work fine with an older dynamically linked library so long as they don't access any new features. Applications using new features should ensure the libiio version is compatible by using <a class="el" href="group__TopLevel.html#gaaa29e5bac86d00a1cef6e2d00b0ea24c" title="Get the version of the libiio library.">iio_library_get_version()</a> to avoid undefined behavior. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    Copyright <a href="https://github.com/analogdevicesinc/libiio/blob/master/Contributors.md">libIIO Contributors</a>
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
