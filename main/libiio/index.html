<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libiio: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libiio
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Library for interfacing with IIO devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libiio Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#license">License</a></li>
<li class="level1"><a href="#code_model">Code Model</a></li>
<li class="level1"><a href="#scan_contexts">Scanning for IIO contexts</a></li>
<li class="level1"><a href="#creating_context">Creating a context</a><ul><li class="level2"><a href="#navigation">Navigation</a><ul><li class="level3"><a href="#device_obj">Device objects</a></li>
<li class="level3"><a href="#channel_obj">Channel objects</a></li>
</ul>
</li>
<li class="level2"><a href="#list_params">Parameters</a></li>
</ul>
</li>
<li class="level1"><a href="#reading_modify_params">Reading and modifying parameters</a><ul><li class="level2"><a href="#read_param">Reading a parameter</a></li>
<li class="level2"><a href="#write_param">Modifying a parameter</a></li>
</ul>
</li>
<li class="level1"><a href="#trigger">Triggers</a></li>
<li class="level1"><a href="#capture_upload">Capturing or uploading samples</a><ul><li class="level2"><a href="#create_buffer">Enabling channels and creating the Buffer object</a></li>
<li class="level2"><a href="#refill">Refilling the Buffer (input devices only)</a></li>
<li class="level2"><a href="#read_write">Reading or writing samples to the Buffer</a><ul><li class="level3"><a href="#memcpy">Direct copy</a></li>
<li class="level3"><a href="#iterating_cb">Iterating over the buffer with a callback</a></li>
<li class="level3"><a href="#iterating_for">Iterating on the samples with a for loop</a></li>
<li class="level3"><a href="#deinterleave">Extracting from/to a second buffer</a></li>
</ul>
</li>
<li class="level2"><a href="#convert">Convert the samples from/to hardware format</a></li>
<li class="level2"><a href="#push">Submitting the Buffer (output devices only)</a></li>
</ul>
</li>
<li class="level1"><a href="#advanced">Advanced options</a><ul><li class="level2"><a href="#userdata">Register and retrieve a pointer</a></li>
<li class="level2"><a href="#debug_attr">Debug attributes</a></li>
<li class="level2"><a href="#registers">Reading and writing registers</a></li>
</ul>
</li>
<li class="level1"><a href="#abi">Application Binary Interface</a></li>
</ul>
</div>
<div class="textblock"><p><a href="../index.html">Back to libIIO</a></p>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>Libiio has been developed and is released under the terms of the GNU Lesser General Public License, version 2 or (at your option) any later version. This open-source license allows anyone to use the library for proprietary or open-source, commercial or non-commercial applications.</p>
<p>Separately, the IIO Library also includes a set of test examples and utilities, (collectively known as iio-utils) which are developed and released under the terms of the GNU General Public License, version 2 or (at your option) any later version.</p>
<p>The full terms of the library license can be found at: <a href="http://opensource.org/licenses/LGPL-2.1">http://opensource.org/licenses/LGPL-2.1</a> and the iio-utils license can be found at: <a href="https://opensource.org/licenses/GPL-2.0">https://opensource.org/licenses/GPL-2.0</a></p>
<h1><a class="anchor" id="code_model"></a>
Code Model</h1>
<p>The basic bricks of the libiio API are the iio_context, iio_device, iio_channel and iio_buffer classes.</p>
<p><img src="codemodel.svg" alt="" style="pointer-events: none;" class="inline" title="Caption text"/></p>
<ul>
<li>A iio_context object may contain zero or more iio_device objects. A iio_device object is associated with only one iio_context. This object represents an instance of the library.</li>
<li>A iio_device object may contain zero or more iio_channel objects. A iio_channel object is associated with only one iio_device.</li>
<li>A iio_device object may be associated with one iio_buffer object, and a iio_buffer object is associated with only one iio_device.</li>
</ul>
<p>A C++ API is provided in iio.hpp</p>
<h1><a class="anchor" id="scan_contexts"></a>
Scanning for IIO contexts</h1>
<p>The first step when dealing with a collection of IIO devices (known as a context) is to find the context. This can be connected via usb, network, serial or local. Having these different connectivity options could prove to be problematic, but libiio abstracts the low level communications away, and allows you just to find contexts, and talk to devices without being interested in the low level aspects. Many find this convenient to develop applications and algorithms on a host, and quickly move to an embedded Linux system without having to change any code.</p>
<p>To find what IIO contexts are available, use the following:</p><ul>
<li><a class="el" href="group__TopLevel.html#gaa333dd2e410a2769cf5685019185d99c" title="Create a scan context.">iio_create_scan_context()</a>: Create a iio_scan_context object. Depending on what backends were enabled with compiling the library, some of them may not be available. The first argument to this function is a string which is used as a filter ("usb:", "ip:", "local:", "usb:ip", where the default (NULL) means any backend that is compiled in).</li>
<li><a class="el" href="group__TopLevel.html#ga5d364d8d008bdbfe5486e6329d06257f" title="Enumerate available contexts.">iio_scan_context_get_info_list()</a>: get the iio_context_info object from the iio_scan_context object. The iio_context_info object can be examined with the <a class="el" href="group__TopLevel.html#ga885558697d0e4dad11a4a5b6f5fbc4d6" title="Get a description of a discovered context.">iio_context_info_get_description()</a> and <a class="el" href="group__TopLevel.html#ga6a142a62112a0f84370d22facb2f2a37" title="Get the URI of a discovered context.">iio_context_info_get_uri()</a> to determine which uri you want to attach to.</li>
</ul>
<h1><a class="anchor" id="creating_context"></a>
Creating a context</h1>
<p>Different functions are available to create the iio_context object. Depending on what backends were enabled when compiling the library, some of them may not be available. Each function will result in a different backend being used.</p>
<p>Those functions are:</p><ul>
<li><a class="el" href="group__TopLevel.html#gafdcee40508700fa395370b6c636e16fe" title="Create a context from a URI description.">iio_create_context_from_uri()</a>: This should be the main function to create contexts, which takes a Uniform Resource Identifier (uri), and returns a iio_context.</li>
<li><a class="el" href="group__TopLevel.html#ga21076125f817a680e0c01d4a490f0416" title="Create a context from local or remote IIO devices.">iio_create_default_context()</a>: Create a "local" context if we can, otherwise use the ENV_VAR IIOD_REMOTE.</li>
<li><a class="el" href="group__TopLevel.html#gaf31acec2d0f9f498870cc52a1d49783e" title="Create a context from local IIO devices (Linux only)">iio_create_local_context()</a>: Create a "local" context, to use the IIO devices connected to the system (typically for cross-compiled applications).</li>
<li><a class="el" href="group__TopLevel.html#ga8adf2ef4d2b62aa34201469cd7049617" title="Create a context from the network.">iio_create_network_context()</a>: Create a "network" context that will work with a remotely connected target.</li>
</ul>
<p>Note that every function that compose the API of libiio will work independently of the function that was used to create the iio_context object.</p>
<p>The iio_context object can later be destroyed with iio_context_destroy().</p>
<h2><a class="anchor" id="navigation"></a>
Navigation</h2>
<h3><a class="anchor" id="device_obj"></a>
Device objects</h3>
<ul>
<li>From the iio_context object, you can obtain the number of available devices with iio_context_get_devices_count().</li>
<li>Then, each iio_device object can be accessed with iio_context_get_device().</li>
<li>Alternatively, it is possible to lookup for a device name or ID with iio_context_find_device().</li>
</ul>
<p>Each iio_device object has an ID that can be used as identifier. This ID can be retrieved with iio_device_get_id(). It optionally also has a name, that can be retrieved with iio_device_get_name().</p>
<h3><a class="anchor" id="channel_obj"></a>
Channel objects</h3>
<ul>
<li>From the iio_device object, you can obtain the number of available channels with iio_device_get_channels_count().</li>
<li>Then, each iio_channel object can be accessed with iio_device_get_channel().</li>
<li>Alternatively, it is possible to lookup for a channel name or ID with iio_device_find_channel().</li>
</ul>
<p>Each iio_channel can be either input, or output. This information can be retrieved with iio_channel_is_output(). As for the Device objects, the iio_channel object features an ID and optionally a name. The ID can be obtained with iio_channel_get_id(), and the name can be obtained with iio_channel_get_name(). Important note: two iio_channel can have the same ID, as long as one is input and the other is output.</p>
<h2><a class="anchor" id="list_params"></a>
Parameters</h2>
<p>Different kinds of parameters are available: parameters that apply to a iio_device, and parameters that apply to one or more iio_channel.</p><ul>
<li>The number of device-specific parameters can be obtained with iio_device_get_attrs_count(). Each attribute name can be obtained with iio_device_get_attr().</li>
<li>The number of channel-specific attributes can be obtained with iio_channel_get_attrs_count(). Each attribute name can be obtained with iio_channel_get_attr().</li>
</ul>
<p>Alternatively, it is possible to lookup for the name of an attribute with iio_device_find_attr() and iio_channel_find_attr().</p>
<h1><a class="anchor" id="reading_modify_params"></a>
Reading and modifying parameters</h1>
<h2><a class="anchor" id="read_param"></a>
Reading a parameter</h2>
<p>Read device-specific attributes with those functions:</p><ul>
<li>iio_device_attr_read()</li>
<li>iio_device_attr_read_all()</li>
<li>iio_device_attr_read_bool()</li>
<li>iio_device_attr_read_longlong()</li>
<li>iio_device_attr_read_double()</li>
</ul>
<p>Read channel-specific attributes with those functions:</p><ul>
<li>iio_channel_attr_read()</li>
<li>iio_channel_attr_read_all()</li>
<li>iio_channel_attr_read_bool()</li>
<li>iio_channel_attr_read_longlong()</li>
<li>iio_channel_attr_read_double()</li>
</ul>
<p>Read debug attributes with those functions:</p><ul>
<li>iio_device_debug_attr_read()</li>
<li>iio_device_debug_attr_read_all()</li>
<li>iio_device_debug_attr_read_bool()</li>
<li>iio_device_debug_attr_read_longlong()</li>
<li>iio_device_debug_attr_read_double()</li>
</ul>
<h2><a class="anchor" id="write_param"></a>
Modifying a parameter</h2>
<p>Write device-specific attributes with those functions:</p><ul>
<li>iio_device_attr_write()</li>
<li>iio_device_attr_write_all()</li>
<li>iio_device_attr_write_bool()</li>
<li>iio_device_attr_write_longlong()</li>
<li>iio_device_attr_write_double()</li>
</ul>
<p>Write channel-specific attributes with those functions:</p><ul>
<li>iio_channel_attr_write()</li>
<li>iio_channel_attr_write_all()</li>
<li>iio_channel_attr_write_bool()</li>
<li>iio_channel_attr_write_longlong()</li>
<li>iio_channel_attr_write_double()</li>
</ul>
<p>Write debug attributes with those functions:</p><ul>
<li>iio_device_debug_attr_write()</li>
<li>iio_device_debug_attr_write_all()</li>
<li>iio_device_debug_attr_write_bool()</li>
<li>iio_device_debug_attr_write_longlong()</li>
<li>iio_device_debug_attr_write_double()</li>
</ul>
<h1><a class="anchor" id="trigger"></a>
Triggers</h1>
<p>Some devices, mostly low-speed ADCs and DACs, require a trigger to be set for the capture or upload process to work.</p>
<p>In libiio, triggers are just regular iio_device objects. To check if an iio_device can be used as a trigger, you can use iio_device_is_trigger().</p>
<p>To see if one device is associated with a trigger, use iio_device_get_trigger().</p>
<p>To assign one trigger to a iio_device, you can use iio_device_set_trigger(). If you want to disassociate a iio_device from its trigger, pass NULL to the "trigger" parameter of this function.</p>
<h1><a class="anchor" id="capture_upload"></a>
Capturing or uploading samples</h1>
<p>The process of capturing samples from the hardware and uploading samples to the hardware is done using the functions that apply to the iio_buffer object.</p>
<h2><a class="anchor" id="create_buffer"></a>
Enabling channels and creating the Buffer object</h2>
<p>The very first step is to enable the capture channels that we want to use, and disable those that we don't need. This is done with the functions iio_channel_enable() and iio_channel_disable(). Note that the channels will really be enabled or disabled when the iio_buffer object is created.</p>
<p>Also, not all channels can be enabled. To know whether or not one channel can be enabled, use iio_channel_is_scan_element().</p>
<p>Once the channels have been enabled, and triggers assigned (for triggered buffers) the iio_buffer object can be created from the iio_device object that will be used, with the function iio_device_create_buffer(). This call will fail if no channels have been enabled, or for triggered buffers, if the trigger has not been assigned.</p>
<p>When the object is no more needed, it can be destroyed with iio_buffer_destroy().</p>
<h2><a class="anchor" id="refill"></a>
Refilling the Buffer (input devices only)</h2>
<p>If the Buffer object has been created from a device with input channels, then it must be updated first. This is done with the iio_buffer_refill() function.</p>
<h2><a class="anchor" id="read_write"></a>
Reading or writing samples to the Buffer</h2>
<p>Libiio offers various ways to interact with the iio_buffer object.</p>
<h3><a class="anchor" id="memcpy"></a>
Direct copy</h3>
<p>If you already have a buffer of samples, correctly interleaved and in the format that the hardware expects, it is possible to copy the samples directly into the iio_buffer object using <code>memcpy</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> iio_buf_size = iio_buffer_end(buffer) - iio_buffer_start(buffer);</div>
<div class="line"><span class="keywordtype">size_t</span> count = MAX(<span class="keyword">sizeof</span>(samples_buffer), iio_buf_size);</div>
<div class="line">memcpy(iio_buffer_start(buffer), samples_buffer, count);</div>
</div><!-- fragment --><p>Using <code>memcpy</code> to copy samples from the iio_buffer is <b>not recommended</b>. When capturing samples from an input device, you cannot assume that the iio_buffer object contains only the samples you're interested in.</p>
<h3><a class="anchor" id="iterating_cb"></a>
Iterating over the buffer with a callback</h3>
<p>Libiio provides a way to iterate over the buffer by registering a callback function, with the iio_buffer_foreach_sample() function.</p>
<p>The callback function will be called for each "sample slot" of the buffer, which will contain a valid sample if the buffer has been refilled, or correspond to an area where a sample should be stored if using an output device.</p>
<div class="fragment"><div class="line">ssize_t sample_cb(<span class="keyword">const</span> <span class="keyword">struct</span> iio_channel *chn, <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> bytes, <span class="keywordtype">void</span> *d)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Use &quot;src&quot; to read or write a sample for this channel */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    iio_buffer_foreach_sample(buffer, sample_cb, NULL);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the callback will be called in the order that the samples appear in the buffer, and only for samples that correspond to channels that were enabled.</p>
<h3><a class="anchor" id="iterating_for"></a>
Iterating on the samples with a for loop</h3>
<p>This method allows you to iterate over the samples slots that correspond to one channel. As such, it is interesting if you want to process the data channel by channel.</p>
<p>It basically consists in a for loop that uses the functions iio_buffer_first(), iio_buffer_step() and iio_buffer_end():</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">void</span> *ptr = iio_buffer_first(buffer, channel);</div>
<div class="line">           ptr &lt; iio_buffer_end(buffer);</div>
<div class="line">           ptr += iio_buffer_step(buffer)) {</div>
<div class="line">    <span class="comment">/* Use &quot;ptr&quot; to read or write a sample for this channel */</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="deinterleave"></a>
Extracting from/to a second buffer</h3>
<p>Finally, it is possible to use the iio_channel_read() and iio_channel_read_raw() functions to read samples from the iio_buffer to a second byte array. The samples will be deinterleaved if needed. The "raw" variant will only deinterleave the samples, while the other variant will deinterleave and convert the samples.</p>
<p>For output devices, the iio_channel_write() and iio_channel_write_raw() functions are also available. The "raw" variant will only interleave the samples (if needed), while the other variant will interleave and convert the samples back to their hardware format.</p>
<h2><a class="anchor" id="convert"></a>
Convert the samples from/to hardware format</h2>
<p>The raw stream of samples generally isn't in a format that can be directly used in algorithms. Some operations, like endianness conversion and bit-shifting of the samples, have to be performed first.</p>
<p>Libiio offers two functions that can be used to convert samples:</p><ul>
<li>iio_channel_convert(), to convert from the hardware format</li>
<li>iio_channel_convert_inverse(), to convert to the hardware format.</li>
</ul>
<p>Those two functions should always be used when manipulating the samples of the iio_buffer. The exception is when iio_channel_read() or iio_channel_write() are used, as the conversion is then done internally.</p>
<h2><a class="anchor" id="push"></a>
Submitting the Buffer (output devices only)</h2>
<p>When all the samples have been written to the iio_buffer object, you can submit the buffer to the hardware with a call to iio_buffer_push(). As soon as the buffer has been submitted, it can be reused to store new samples.</p>
<p>If the iio_buffer object has been created with the "cyclic" parameter set, and the kernel driver supports cyclic buffers, the submitted buffer will be repeated until the iio_buffer is destroyed, and no subsequent call to iio_buffer_push() will be allowed.</p>
<h1><a class="anchor" id="advanced"></a>
Advanced options</h1>
<h2><a class="anchor" id="userdata"></a>
Register and retrieve a pointer</h2>
<p>The iio_device and iio_channel allow you to register a pointer, that can then be retrieved at a later moment.</p><ul>
<li>A pointer can be registered with a iio_device object using iio_device_set_data(), and can be retrieved with iio_device_get_data().</li>
<li>A pointer can be registered with a iio_channel object using iio_channel_set_data(), and can be retrieved with iio_channel_get_data().</li>
</ul>
<h2><a class="anchor" id="debug_attr"></a>
Debug attributes</h2>
<p>Some IIO devices provide debug parameters, but their presence is optional. In a similar way than with regular device parameters, the number of debug parameters can be obtained with iio_device_get_debug_attrs_count(). Each individual parameter can be retrieved with iio_device_get_debug_attr(). Alternatively, it is possible to lookup for the name of a debug attribute with iio_device_find_debug_attr().</p>
<p>Those debug parameters can be read using the following functions:</p><ul>
<li>iio_device_debug_attr_read(),</li>
<li>iio_device_debug_attr_read_all(),</li>
<li>iio_device_debug_attr_read_bool(),</li>
<li>iio_device_debug_attr_read_longlong(),</li>
<li>iio_device_debug_attr_read_double().</li>
</ul>
<p>Those debug parameters can be written using the following functions:</p><ul>
<li>iio_device_debug_attr_write(),</li>
<li>iio_device_debug_attr_write_all(),</li>
<li>iio_device_debug_attr_write_bool(),</li>
<li>iio_device_debug_attr_write_longlong(),</li>
<li>iio_device_debug_attr_write_double().</li>
</ul>
<h2><a class="anchor" id="registers"></a>
Reading and writing registers</h2>
<p>As for debug attributes, some IIO devices also offer the possibility to read and write hardware registers directly. In libiio, this can be done with two functions, iio_device_reg_read() and iio_device_reg_write().</p>
<h1><a class="anchor" id="abi"></a>
Application Binary Interface</h1>
<p>The libiio ABI tries to be both backwards and forwards compatible. This means applications compiled against an older version will work fine with a newer dynamically linked library. Applications compiled against a newer version will work fine with an older dynamically linked library so long as they don't access any new features. Applications using new features should ensure the libiio version is compatible by using <a class="el" href="group__TopLevel.html#gaaa29e5bac86d00a1cef6e2d00b0ea24c" title="Get the version of the libiio library.">iio_library_get_version()</a> to avoid undefined behavior. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    Copyright <a href="https://github.com/analogdevicesinc/libiio/blob/master/Contributors.md">libIIO Contributors</a>
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
